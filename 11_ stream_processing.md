스트림 처리
=

batch는 입력 데이터의 크기를 알아야하고, 그렇기 때문에 일정 주기로 사용되어 반영이 느리다는 특징이 있다. 이러한 한계를 극복하게 해주는 특징을 stream processing은 가지고 있다.

스트림 : 시간 흐름에 따라 점진적으로 생산된 데이터
스트림 처리 : 일괄 처리와 다르게, 단순히 이벤트가 발생할 때마다 처리한다.
이벤트 스트림 : 점진적인 처리, 시간별로 정렬된 일련의 비즈니스 이벤트

이벤트 스트림 전송
=
batch에서 일반적인 입력은 파일의 형태이다. stream에서 입력은 이벤트라고 부른다.

특정 시점에 일어난 사건에 대한 세부 사항을 포함하는 작고 불변의 객체
일반적으로 일기준 시계를 따르는 이벤트 발생 타임스탬프 포함

생산자와 소비자

생산자(producer), 발생자(pubisher), 발송자(sender)는 이벤트를 만든다.
소비자(consumer), 구독자(subscriber), 수신자(recipient)는 이벤트를 처리한다.

스트림 시스템에서는 토픽(topic)이나 스트림으로 관련 이벤트를 묶는다.

스트림 처리와 일괄 처리 비교

- 스트림 처리
  - 생산자는 만들어낸 모든 이벤트를 데이터스토어 기록한다.
  - 소비자가 요청해 데이터 베이스에서 읽어오는 방식은 일괄 처리에는 큰 문제가 되지 않지만, 스트림과 같이 폴링이 빈번하게 발생한다면 문제가 될 수 있다. 그래서 이벤트가 발생했을 때, 생산자가 알림을 보내주는 방식이 주로 사용된다.
  - 각 소비자는 주기적으로 데이터스토어에 폴링해 마지막에 처리한 이후에 새로 발생한 이벤트가 있는지 확인하고 처리한다.

- 일괄 처리
  - 매일 마지막에 그날 데이터 분량을 처리한다.

메시징 시스템
=
메시징 시스템(messaging system) 역할

새로운 이벤트에 대해 소비자에게 알려주려고 쓰이는 일방적인 방법으로 메시징 시스템을 사용한다.
생산자는 이벤트를 포함한 메시지 전송한다.
소비자는 그 메시지를 전달 받는다.

직접 메시징 시스템
=
생산자에서 소비자로 메시지를 직접 전달하기 
중간 노드를 통하지 않고, 생산자와 소비자를 네트워크로 직접 통신

예: UDP, ...

직접 메시징 시스템의 한계

- 메시지가 유실 될 수 있는 가능성을 고려하여 애플리케이션 코드를 작성해야 한다.
- 소비자가 오프라인이라면 메시지를 전달하지 못하는 상태에서 있는 동안 전송된 메시지는 잃어 버릴 수 있다.

메시지 브로커
=
메시지 스트림을 처리하는데 최적화된 데이터베이스의 일종이다.
메시지 브로커는 서버로 구동되고, 생성자와 소비자는 서버의 클라이언트로 접속한다.

메세지 브로커의 이점

- 클라이언트의 상태 변경(접속, 접속 해제, 장애)에 쉽게 대처할 수 있다.
- 브로커가 장애로 중단됐을 때도 메시지를 디스크에 기록하게 되면 유실되지 않는다.
- 메모리에만 메시지를 보관하는 브로커는 유실될 수 있다.
- 소비 속도가 느리면 브로커는 큐에 제한 없이 계속 늘어나게 한다.
- 메시지를 버리거나 배압을 하지 않는다. 다만, 이는 설정으로 변경할 수도 있다.

큐에 대기하게 되면 소비자는 비동기로 동작

- 생산자는 메시지를 브로커에 보내면 해당 메시지는 버퍼에 쌓이게 되고, 소비가 될 때까지 기다리지 않는다.
- 소비자는 메시지를 바로 소비할도 있지만, 늦게 소비할 수도 있게 된다.

메시지 브로커와 데이터베이스 비교 
=
소비자에게 데이터가 전달되면 자동으로 삭제

대부분의 메시지는 빨리 지우기 때문에 작업 집합이 상당히 작다고 가정한다.

특정 패턴과 부합하는 토픽의 부분 집합을 구독하는 방식의 쿼리 지원

임의 질의를 지원하지 않지만, 변경되면 클라이언트에게 알려 준다.

복수 소비자
=
여러 소비자가 같은 토픽에서 메시지를 읽을 때 사용하는 주요 패턴 2가지

로드 밸런싱
- 각 메시지는 소비자 중 하나로 전달된다.
- 브로커는 메시지를 전달할 소비자를 임의로 지정한다.
  
팬 아웃(fan-out)
- 각 메시지는 모든 소비자에게 전달된다.
- 여러 독립적인 소비자가 브로드캐스팅된 동일한 메시지를 서로 간섭 없이 전달 받을 수 있다.

이 두가지 패턴을 함께 사용 가능
- 두 개의 소비자 그룹에서 하나의 토픽을 구독한다.
- 각 그룹은 모든 메시지를 받지만, 그룹 내에서는 각 메시지를 하나의 노드만 받게 하는 식이다.

확인 응답과 재전송
=

파티션닝된 로그
=
메시지 브로커도 디스크에 지속성 있기 기록을 하지만, 소비자가 전달될 후 즉시 삭제한다.
메시지 브로커는 일시적 보관 개념으로 만들어 졌다.
메시지 브로커는 메시지가 전달을 하게 되면, 확인 응답을 받고 삭제한다. 이는 복구되지 않는다.

데이터베이스의 지속성 있는 저장 방법과 메시징 시스템 지연 시간이 짧은 알림 기능의 조합이 로그 기반 메시지 브로커(log-based message broker) 이다.

로그: 단순히 디스크에 저장된 추가 전용 레코드의 연속이다. 로그 구조화 저장 엔진과 쓰기 전 로그, 복제본의 로그와 같은 맥락.

생산자가 보낸 메시지는 로그 끝에 추가한다.
소비자는 로그를 순차적으로 읽어 메시지를 받는다. 로그 끝에 도달하면 새 메시지가 추가됐다는 알림을 기다린다.

로그 파티셔닝: 디스크 하나를 쓸 때보다 로그 처리량을 높이기 위해 파티셔닝을 하는 방법이다.

오프셋(offset): 각 파티션 내에서 브로커는 모든 메시지에 단순히 증가하는 순번인 오프셋을 부여한다. 다른 파티션 간 메시지의 순서는 보장하지 않는다.

로그 기반 접근법의 장단점
=

장점
- 메시지 처리 속도가 빠르다.
- 메시지 순서가 중요하다면 효과적이다.
  
단점
- 메시지 처리 비용이 비싸다.
- 메시지 순서가 중요하지 않다면 JMS/AMQP 방식의 메시지 브로커가 더 적합하다.


소비자 오프셋
=
오프셋의 이점

- 파티션 하나를 순서대로 처리하면 메시지를 어디까지 처리했는지 알기 쉽다.
- 메시지마다 보내는 확인 응답을 추적할 필요가 없다.
- 추척 오버헤드가 감소하고 일괄 처리와 파이프라이닝을 수행 할 수 있는 기회를 제공하여 처리량을 늘리는데 도움을 준다.

소비자 노드 장애 발생시 문제점

- 소비자 노드가 장애가 발생하면 그룹내 다른 노드가 오프셋부터 메시지를 처리한다.
- 장애가 발생한 소비자가 처리하였지만, 오프셋이 기록되지 않았다면 두번 처리하게 된다.

디스크 공간 사용 

- 로그가 점차 쌓이게 되면, 결국 디스크를 전부 사용하게 된다.
- 디스크를 재사용하기 위해서는 로그를 여러 조각으로 나누고 오래된 조각은 삭제하거나 보관 저장소로 이동한다.

- 소비자 처리 속도가 느려 생산되는 속도를 따라 잡지 못하면 소비자의 오프셋은 이미 삭제한 조각을 가리킬 수 있다. 즉, 메시지 일부를 잃어버릴 가능성 있다는 뜻이다.
- 로그는 크기가 제한 된 버퍼로 구현하고 오래된 메시지는 순서대로 버린다. 이를 원형 버퍼(circuler buffer), 링 버퍼(ring buffer)라고 한다.

데이터베이스와 스트림
=

시스템 동기화 유지하기 
=
이중 기록(dual write)

- 주기적으로 데이터베이스 전체를 덤프하는 작업이 너무 느리면 대안으로 사용하는 방법
- 이중 기록을 사용하면 데이터가 변할 때마다 애플리케이션 코드에서 명시적으로 각 시스템에 기록

각 클라이언트가 동시에 아이템을 업데이트하려고 할때, 타이밍 문제로 데이터가 맞지 않게 될 수 있다.

동시성 문제
- “동시 쓰기 감지"에서 설명한 버전 벡터와 같은 동시성 감지 매커니즘을 따로 사용하지 않으면 동시에 쓰기 발생해도 알아 차리지 못한다.

내결함성 문제
- 한쪽 쓰기가 성공할 때 다른 쪽 쓰기는 실패할 수 있다.
- 두 시스템 간에 불일치가 발생하는 현상이 발생한다.
- 동시성 또는 동시 실패 보장하는 방식은 원자적 커밋 문제다.

시스템의 통합 리더

- 색인용 인덱스를 데이터베이스의 팔로워로 만들어 실제 리더를 하나만 존재하게 하면, 어느 정도는 보완할 수 있다.

변경 데이터 캡처(change data capture, CDC)
=
데이터베이스에 기록하는 모든 데이터의 변화를 관찰해 다른 시스템으로 데이터를 복제할 수 있다는 추출 과정이다.

데이터베이스의 변경 사항을 캡처해 같은 변경 사항을 검색 색인에 꾸준히 반영할 수 있다.

변경 데이터 캡처의 구현
=
파생 테이터 시스템: 검색 색인과 데이터 웨어하우스에 저장된 데이터는 레코드 시스템에 저장된 데이터의 또 다른 뷰일 뿐이므로 로그 소비자이다.

변경 데이터 캡처

- 파생 데이터 시스템이 레코드 시스템의 정확한 데이터 복제본을 가지게 하기 위해 레코드 시스템에 발생하는 모든 변경 사항을 파생 데이터 시스템에 반영하는 것을 보장하는 메커니즘이다.
- 본질적으로 변경 사항을 캡처할 데이터베이스 하나를 리더로 하고 나머지를 팔로워로 한다.
- 로그 기반 메시지 브로커는 원본 데이터베이스에서 변경 이벤트를 전송하기에 적합하다. 메시지를 순서를 유지하기 때문이다.

변경 데이터 캡처의 구현

- 데이터베이스 트리거를 사용하는 방식
- 복제 로그를 방식하는 방식

초기 스냅숏 
=
변경 로그의 위치나 오프셋에 대응돼야 한다.
그래야 스냅숏 이후에 변경 사항을 적용할 시점을 알 수 있다.

로그 컴팩션

로그 히스토리의 양을 제한한다면 새로운 파생 데이터 시스템을 추가할 때마다 스냅숏을 만들어야 한다.

로그 컴팩션 동작 원리

- 저장 엔진은 주기적으로 같은 키의 로그 레코드를 찾아 중복 제거한다.
- 각 키에 대한 가장 최근에 갱신된 내용만 유지한다.
- 컴팩션 병합 과정은 백그라운드로 실행한다.

이벤트 소싱 
=
이벤트 소싱(event sourcing)

- 도메인 주도 설계(domain-driven design, DDD) 커뮤니티에서 개발한 기법이다.
- 애플리케이션 상태 변화를 모두 변경 이벤트 로그로 저장한다. 변경 데이터 캡처와 유사하다.

이벤트 데이터 캡처와 이벤트 소싱 차이점

- 이벤트 데이터 캡처
  - 애플리케이션은 데이터베이스를 변경 가능한 방식으로 사용해 레코드를 자유롭게 갱신하고 삭제한다.
    - 추가(O) 갱신(O), 삭제(O)
  - 변경 로그는 데이터베이스에서 추출한 쓰기 순서가 실제로 데이터를 기록한 순서와 일치한다.
  - 데이터베이스에 기록한 애플리케이션은 CDC가 실행 중인지 알 필요가 없다.
- 이벤트 소싱
  - 애플리케이션 로직은 이벤트 로그에 기록된 불변 이벤트를 기반으로 명시적으로 구축한다.이는 단지 추가만 가능하고 갱신이나 삭제는 권장하지 않거나 금지한다는 것의 의미한다.
    - 추가(O) 갱신(X), 삭제(X)
  - 이벤트는 저수준에서 상태 변경을 반영하는 것이 아니라 애플리케이션 수준에서 발생한 일을 반영하게끔 설계 됐다.-

이벤트 소싱의 이점

- 데이터 모델링에 쓸 수 있는 강력한 기법이다.
- 애플리케이션 관점에서 사용자의 행동을 불변 이벤트로 기록하는 방식
- 애플리케이션을 지속해서 개선하기가 매우 유리하다.
- 디버깅에 도움이 되고, 애플리케이션 버그를 방지한다.
- 이벤트 소싱 접근법을 사용하며 새로 발생한 부수 효과를 기존 이벤트에서 쉽게 분리할 수 있다.

이벤트 소싱은 이벤트 로그 컴팩션이 불가능하다.
이벤트 소싱 시스템은 모든 원시 이벤트를 영원히 저장하고 필요할 때마다 모든 이벤트를 재처리 할 수 있어야 한다.

명령과 이벤트
=
명령(command)이란?

사용자 요청이 처음 도착했을 때 이 요청은 명령이다. 특정 무결성 조건을 위반하면 실패한다.
무결성이 검증되고 명령이 승인 되면 지속성 있는 불변 이벤트가 된다.

이벤트 불변 이벤트가 한번 생성되면 사실(fact)가 된다.
다시 변경 및 취소가 되었더라고 기존 정보는 여전히 사실로 남아 있으며, 다시 변경 및 취소는 나중에 추가된 독립적인 이벤트가 된다.

이벤트 스트림 소비자 소비자는 이벤트를 거절 못한다. 이벤트를 받은 시점에는 이벤트는 이미 불변 로그의 일부분이다. 명령 유효성은 이벤트가 되기 전에 검증해야 한다. 이를테면 직렬성 트랜잭션을 사용해 원자적으로 명령을 검증하고 이벤트를 발행 할 수 있다.

상태와 스트림 그리고 불변성
=

입력 파일에 손상을 주지 않고 기존 입력 파일에 얼마든지 실험적 처리 작업을 수행할 수 있다.
불변성 원리가 이벤트 소싱과 변경 데이터 캡처를 매우 강력하게 만든다.

동일한 이벤트 로그로 여러 가지 뷰 만들기 
=
명령 질의 책임의 분리(command query responsibility segregation, CQRS)

- 데이터를 어떻게 질의하고 접근하는지 신경 쓰지 않는다면, 데이터 저장은 상당히 직관적인 작업이다.
- 데이터를 쓰는 형식, 읽는 형식을 분리해 다양한 읽기 뷰를 혀용한다면 상당한 유연성을 얻을 수 있다.

- 데이터베이스와 스키마 설계의 전통적인 접근법은 데이터를 질의 받게 될 형식과 같은 형식으로 데이터를 기록해야 한다는 잘못된 생각에 기초한다.
- 데이터를 쓰기 최적화된 이벤트 로그에서 읽기 최적화된 애플리케이션 상태로 전환 가능하면 정규화와 비정규화에 관한 논쟁은 의미 없다.
- 읽기 최적화된 뷰는 데이터를 비정규화하는 것이 전적으로 합리적이다.

동시성 제어 
=
이벤트 소싱과 변경 데이터 캡처의 가장 큰 단점은 이벤트 로그의 소비가 대개 비동기로 이뤄진다는 점이다.

사용자가 로그에 이벤트를 기록하고, 이어서 파생된 뷰를 읽어도 기록한 이벤트가 뷰에 반영되지 않았을 가능성이 있다.

해결책으로 하나는 읽기 뷰의 갱신과 로그에 이벤트를 추가하는 작업을 동기식으로 수행하는 방법이 있다.

반면 이벤트 로그를 현재 상태로 만들면 동시성 제어 측면이 단순해진다.

그러면 사용자 동작은 한 장소에서 한 번 쓰기만 필요하다. 즉, 이벤트를 로그에 추가만 하면 되며 원자적으로 만들기 쉽다.

이벤트 로그와 상태를 같은 방식으로 파티셔닝하면, 간단한 단일 스레드 로그 소비자는 쓰기용 동시성 제어는 필요하지 않다.

스트림 처리
=
스트림을 처리하는 방법

1. 이벤트에서 데이터를 꺼내 데이터베이스나 캐시,검색 색인 또는 유사한 저장소 시스템에 기록하고, 다른 클라이언트가 이 시스템에 해당 데이터를 질의한다.
2. 이벤트를 사용자에게 직접 보낸다.
3. 하나 이상의 입력 스트림을 처리해 하나 이상의 출력 스트림을 생산한다.

내결함성
=
일괄 처리는 일부 태스크가 실패할지라도 재처리가 가능하다.
스트림 처리는 무한하다. 그래서 처리를 절대 완료할 수 없다.

마이크로 일괄처리(microbatching): 스트림을 작은 블록으로 나누고 각 블록을 소형 일괄 처리와 같이 다루는 방법이다.

체크포인트(checkpoint): 주기적으로 상태의 롤링 체크포인트를 생성하고 지속성 있는 저장소에 저장한다.

원자적 커밋 재검토: 장애가 발생했을 때 정확히 한 번 처리되는 것처럼 보일려면 처리가 성공했을 때만 모든 출력과 이벤트 처리의 부수 효과가 발생하게 해야 한다.

멱등성(idempotence)

결국 목표는 처리 효과가 두 번 나타나는 일 없이 안전하게 재처리하기 위해 실패한 태스크의 부분 출력을 버리는 것

멱등 연산: 여러 번 수행하더라도 오직 한 번 수행한 것과 같은 효과를 내는 연산
연산 자체가 멱등적이지 않아도 약간의 여분 메타데이터로 연산을 멱등적으로 만들 수 있다.

모든 메시지에는 영속적이고 단조 증가하는 오프셋이 있다.

트리거한 메시지의 오프셋을 함께 포함한다면 이미 갱신이 적용됐는지 확인할 수 있기 때문에 반복해서 같은 갱신이 수행되는 것을 막을 수 있다.

