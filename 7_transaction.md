ACID
=
- 원자성: 전부 반영되거나 아무것도 반영되지 않는 것
- 일관성: 데이터베이스 자체만으로 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다(어플리케이션 속성)
- 격리성: 동시에 실행되는 트랜잭션은 서로 격리되어 방해할 수 없다.
- 지속성: 안전한 저장소를 제공하는 것

단일객체 쓰기
=
원자성과 격리성을 단일 객체를 변경하는 경우에도 적용하는 것

다중 객체 트랜잭션의 필요성
=
다중 객체 트랜잭션 : 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요

완화된 격리 수준
=
커밋 후 읽기 (READ COMMITTED): 
- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기가 없음)
- 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기가 없음)

더티 읽기(dirty read) : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상

커밋 후 읽기는 Oracle 11g, PostgreSQL, SQL Server 2012, MemSQL 등에서 기본 설정으로 쓰고 있는 격리 수준이다.

- 더티쓰기 방지 : 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유한다.
- 더티 읽기 방지: 과거의 커밋된 값/현재 쓰고 있는 새로운 값을 모두 기억하고 해당 트랜잭션이 실행 중인 동안 과거의 값을 읽게하여 더티 읽기를 방지 할 수 있다.

스냅숏 격리와 반복 읽기(Snapshot Isolation)
=
커밋 후 읽기 격리 수준에서도 동시성 버그가 생길 수 있으며 이런 현상을 비반복 읽기(nonrepeatable read)나 읽기 스큐(read skew)라고 한다.

스냅숏 격리 : 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는 구현

즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.

다중 버전 동시성 제어(multi-version concurrency control, MVCC) : 데이터베이스가 객체의 여러 버전을 함께 유지하는 기법

커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용하는 차이 즉 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가느냐에 따라 다르다.

트랜잭션 ID가 더 큰(즉 현재 트랜잭션이 시작한 후에 시작한) 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시된다.

스냅숏 격리는 읽기 전용 트랜잭션에서 유용하며, SQL 표준에 스냅숏 격리의 개념이 없기 때문에 여러 데이터베이스에서 다른 이름으로 불린다. 
- Oracle: 직렬성(Serializable)
- PostgreSQL, MySQL: 반복 읽기(Repeatable Read)

갱신 손실 방지
=
만약 두 트랜잭션이 작업을 동시에 하면 두번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있음

- 원자적 쓰기 연산: 쓰기 연산에 원사성 (Atomicity) 성질을 부여함으로서 동시성 안전 획득, exclusive lock or 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 방법
- 명시적인 잠금: 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것
다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 첫 번째 read-modify-write 주기가 완료될 때까지 기다리도록 강제됨
- 갱신 손실 자동 감지: 여러 트랜잭션의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 abort 시키고, 재시도하도록 강제하는 방법
- Compare-and-set: 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것
- 충돌 해소와 복제:  쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전을 생성하는 것을 허용하고, 추후에 충돌을 해소하고 이 버전들을 병합함

쓰기 스큐와 팬텀
=
어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 것을 팬텀(Phantom) 이라고 함

직렬성
=
여러 트랜잭션이 병렬로 실행되더라도, 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장

직렬성을 제공하는 3가지 기법
- 말 그대로 트랜잭션을 순차적으로 실행하기
- 2단계 잠금
- 직렬성 스냅숏 격리 같은 낙관적 동시성 제어 기법

직렬 실행 요약
- 모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 전체 처리를 지연시킬 수 있기 때문.
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한됨, 단일 스레드 - 트랜잭션에서 디스크에 접근한다면 시스템이 매우 느려짐
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 함
- 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만, 이것을 사용할 수 있는 정도에는 엄격한 제한이 있음

2단계 잠금은 비관적 동시성 제어 메커니즘, 직렬성 스냅숏 격리는 낙관적 동시성 제어 메커니즘


